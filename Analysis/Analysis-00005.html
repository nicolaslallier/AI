<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Spécification – Intégration du front-end SPA avec Keycloak (OIDC)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<body>
<main>
  <h1>Spécification – Intégration du front-end SPA avec Keycloak</h1>

  <!-- Résumé exécutif -->
  <section id="resume-executif">
    <h2>Résumé exécutif</h2>
    <p>
      Cette spécification décrit comment le <strong>front-end micro front end SPA</strong> doit s’intégrer à
      <strong>Keycloak</strong> pour gérer l’authentification (login/logout, SSO) et l’autorisation (rôles, claims).
    </p>
    <p>
      Le front-end agit comme <strong>client OIDC/public</strong> (PKCE), redirige l’utilisateur vers Keycloak pour
      l’authentification, stocke les tokens de façon sécurisée, applique les rôles au niveau de l’UI (menus, routes,
      actions) et envoie les <code>access_token</code> aux APIs back-end via l’en-tête
      <code>Authorization: Bearer &lt;token&gt;</code>.
    </p>
    <p>
      La solution doit être compatible avec une architecture en <strong>micro front ends</strong> (shell + micro apps),
      respecter les contraintes de <strong>sécurité</strong> et de <strong>conformité</strong> (Loi&nbsp;25, minimisation
      des PII) et être suffisamment précise pour que le Dev AI génère le code front (routes, guards, services d’auth).
    </p>
  </section>

  <!-- Contexte & objectifs -->
  <section id="contexte-objectifs">
    <h2>1. Contexte &amp; objectifs</h2>

    <h3>Contexte</h3>
    <ul>
      <li>Front-end existant en mode <strong>SPA micro front end</strong> (shell + micro applications).</li>
      <li>Back-end(s) protégés, exposés via NGINX / API Gateway et intégrés à Keycloak pour l’auth.</li>
      <li>Keycloak déjà déployé comme fournisseur d’identité (<strong>IdP OIDC</strong>).</li>
    </ul>

    <h3>Objectifs</h3>
    <ul>
      <li>O1 – Permettre au front-end de s’authentifier via Keycloak (OIDC, PKCE) en mode SPA.</li>
      <li>O2 – Gérer les rôles / claims Keycloak côté front pour contrôler menus, écrans, actions.</li>
      <li>O3 – Propager un <strong>access_token</strong> valide vers les APIs back-end (Bearer token).</li>
      <li>O4 – Gérer proprement la session (expiration, renouvellement silencieux, logout global / local).</li>
    </ul>
  </section>

  <!-- Hypothèses -->
  <section id="hypotheses">
    <h2>2. Hypothèses (à confirmer)</h2>
    <ul>
      <li>H1 : Keycloak expose un <strong>realm</strong> dédié (ex. <code>infra-admin</code>) avec un client SPA déclaré.</li>
      <li>H2 : Le client Keycloak utilisé par le front est de type <strong>public</strong> avec <strong>PKCE</strong> activé.</li>
      <li>H3 : Le front-end est une SPA (React / Angular / Vue / autre) avec un système de <strong>routing</strong> interne.</li>
      <li>H4 : Les APIs back-end valident les tokens Keycloak (middleware d’auth côté serveur déjà en place ou prévu).</li>
      <li>H5 : L’URL du front est connue et déclarée dans les <strong>redirect URIs</strong> du client Keycloak (ex. <code>http://localhost:3000/*</code>).</li>
    </ul>
  </section>

  <!-- Exigences business -->
  <section id="br">
    <h2>3. Exigences business (BR)</h2>
    <ul>
      <li>
        <strong>BR-FE-KC-001 – Sécurité des accès front</strong><br />
        L’accès aux fonctionnalités sensibles du front (admin, monitoring, gestion BD, etc.) doit être restreint aux
        utilisateurs authentifiés et autorisés via Keycloak.
      </li>
      <li>
        <strong>BR-FE-KC-002 – Expérience utilisateur fluide (SSO)</strong><br />
        L’utilisateur doit pouvoir se connecter une fois (SSO) et naviguer dans le front (et les micro front ends)
        sans retaper ses identifiants à chaque changement de page.
      </li>
      <li>
        <strong>BR-FE-KC-003 – Traçabilité &amp; conformité</strong><br />
        Les actions sensibles déclenchées depuis le front doivent être corrélables à une identité Keycloak, pour audit
        et conformité (Loi&nbsp;25, sécurité).
      </li>
    </ul>
  </section>

  <!-- Exigences fonctionnelles -->
  <section id="fr">
    <h2>4. Exigences fonctionnelles (FR)</h2>

    <h3>4.1 Initialisation de l’auth dans le front</h3>
    <ul>
      <li>
        <strong>FR-FE-KC-001 – Configuration Keycloak côté front</strong><br />
        Le front doit charger la configuration Keycloak (URL du serveur, realm, clientId, options PKCE) à partir :
        <ul>
          <li>d’un fichier de configuration par environnement (DEV/PPE/PRD) ; ou</li>
          <li>de variables d’environnement injectées au build/run.</li>
        </ul>
      </li>
      <li>
        <strong>FR-FE-KC-002 – Initialisation au démarrage</strong><br />
        Au démarrage de l’application SPA, le front doit :
        <ul>
          <li>initialiser le client OIDC Keycloak ;</li>
          <li>vérifier si un utilisateur est déjà authentifié (session existante / token dans storage) ;</li>
          <li>en cas de session valide, charger les infos utilisateur (id, rôles) dans un <em>store</em> global (state management).</li>
        </ul>
      </li>
    </ul>

    <h3>4.2 Login &amp; logout</h3>
    <ul>
      <li>
        <strong>FR-FE-KC-003 – Redirection vers Keycloak (login)</strong><br />
        Quand l’utilisateur clique sur “Connexion” ou qu’il tente d’accéder à une route protégée non authentifié, le
        front doit :
        <ul>
          <li>construire une requête d’auth OIDC (PKCE, <code>response_type=code</code>) ;</li>
          <li>rediriger vers la page de login Keycloak ;</li>
          <li>gérer le retour (<code>redirect_uri</code>) avec le <code>code</code> d’autorisation pour échanger contre des tokens.</li>
        </ul>
      </li>
      <li>
        <strong>FR-FE-KC-004 – Logout</strong><br />
        Le front doit proposer une action “Déconnexion” qui :
        <ul>
          <li>invalide la session locale (clear des tokens en mémoire/storage) ;</li>
          <li>redirige vers l’endpoint de logout Keycloak pour invalider la session SSO (optionnellement global logout).</li>
        </ul>
      </li>
    </ul>

    <h3>4.3 Gestion des tokens &amp; storage</h3>
    <ul>
      <li>
        <strong>FR-FE-KC-005 – Types de tokens</strong><br />
        Le front doit manipuler au minimum :
        <ul>
          <li>un <code>access_token</code> (pour appeler les APIs) ;</li>
          <li>un <code>id_token</code> (infos d’identité de l’utilisateur) ;</li>
          <li>un <code>refresh_token</code> ou un mécanisme de <strong>silent refresh</strong> selon la stratégie choisie.</li>
        </ul>
      </li>
      <li>
        <strong>FR-FE-KC-006 – Stockage sécurisé</strong><br />
        Les tokens doivent être stockés de façon sécurisée :
        <ul>
          <li>priorité à un <strong>storage en mémoire</strong> (state in-memory) avec refresh silencieux ;</li>
          <li>si usage de <code>sessionStorage</code> ou <code>localStorage</code>, mention explicite des risques XSS et mesures compensatoires.</li>
        </ul>
      </li>
      <li>
        <strong>FR-FE-KC-007 – Renouvellement de token</strong><br />
        Avant expiration de l’<code>access_token</code>, le front doit tenter un <strong>silent refresh</strong>
        (iframe/back-channel ou <code>refresh_token</code>), sinon forcer un nouveau login.
      </li>
    </ul>

    <h3>4.4 Rôles, claims &amp; contrôle d’accès UI</h3>
    <ul>
      <li>
        <strong>FR-FE-KC-008 – Extraction des rôles</strong><br />
        À la suite d’un login, le front doit extraire les rôles/claims depuis le token :
        <ul>
          <li><code>realm_access.roles</code> ;</li>
          <li>et/ou <code>resource_access[clientId].roles</code>, selon la convention Keycloak.</li>
        </ul>
      </li>
      <li>
        <strong>FR-FE-KC-009 – Contrôle des menus &amp; composants</strong><br />
        L’affichage des menus, boutons et sections d’écran doit être conditionné aux rôles (ex. <code>ROLE_DBA</code>,
        <code>ROLE_DEVOPS</code>, <code>ROLE_READONLY</code>), via des garde-fous dans le code (directives, composants d’autorisation).
      </li>
      <li>
        <strong>FR-FE-KC-010 – Guards de route</strong><br />
        Les routes doivent être protégées via des <em>route guards</em> :
        <ul>
          <li>routes nécessitant seulement l’authentification ;</li>
          <li>routes nécessitant des rôles spécifiques (ex. admin only).</li>
        </ul>
      </li>
    </ul>

    <h3>4.5 Appels API sécurisés</h3>
    <ul>
      <li>
        <strong>FR-FE-KC-011 – Injection du token dans les requêtes</strong><br />
        Le front doit injecter automatiquement l’<code>access_token</code> dans les requêtes HTTP sortantes vers les APIs
        protégées, via l’en-tête :
        <code>Authorization: Bearer &lt;access_token&gt;</code>.
      </li>
      <li>
        <strong>FR-FE-KC-012 – Gestion des erreurs 401/403</strong><br />
        En cas de réponse 401/403 du back-end :
        <ul>
          <li>si le token est expiré, tenter un refresh silencieux ;</li>
          <li>sinon rediriger vers le login ou afficher un message “non autorisé”.</li>
        </ul>
      </li>
    </ul>

    <h3>4.6 Spécificités micro front end</h3>
    <ul>
      <li>
        <strong>FR-FE-KC-013 – Session partagée</strong><br />
        Dans un contexte micro front end, la session Keycloak doit être <strong>cohérente</strong> entre le shell et les
        micro front ends :
        <ul>
          <li>soit en centralisant la gestion de l’auth dans le shell ;</li>
          <li>soit en partageant un module commun d’auth (lib JS / module federation).</li>
        </ul>
      </li>
      <li>
        <strong>FR-FE-KC-014 – Propagation d’identité</strong><br />
        Les micro front ends doivent accéder aux informations d’auth (user, rôles, tokens) via une interface bien définie
        (contexte global, events, ou API du shell).
      </li>
    </ul>
  </section>

  <!-- NFR -->
  <section id="nfr">
    <h2>5. Exigences non fonctionnelles (NFR)</h2>
    <ul>
      <li>
        <strong>NFR-FE-KC-001 – Performance</strong><br />
        Le processus de login/refresh ne doit pas dégrader de façon significative l’expérience utilisateur (latence de login raisonnable).
      </li>
      <li>
        <strong>NFR-FE-KC-002 – Sécurité</strong><br />
        Le front doit minimiser l’exposition des tokens (pas de logs de tokens, pas d’injection dans l’URL, protection XSS).
      </li>
      <li>
        <strong>NFR-FE-KC-003 – Résilience</strong><br />
        En cas d’indisponibilité temporaire de Keycloak, le front doit gérer proprement les erreurs (messages UX clairs, pas de boucle infinie).
      </li>
      <li>
        <strong>NFR-FE-KC-004 – Conformité</strong><br />
        L’utilisation des données d’identité (email, nom, etc.) doit respecter la Loi&nbsp;25 (minimisation, pas d’affichage inutile dans les logs).
      </li>
    </ul>
  </section>

  <!-- Data -->
  <section id="data">
    <h2>6. Exigences de données (Data)</h2>
    <ul>
      <li>
        <strong>DATA-FE-KC-001 – Contenu minimal des tokens</strong><br />
        Le front doit se baser sur un set minimal d’attributs Keycloak :
        <ul>
          <li><code>sub</code> : identifiant technique de l’utilisateur ;</li>
          <li><code>preferred_username</code> ou identifiant logique ;</li>
          <li><code>email</code> (si nécessaire) ;</li>
          <li>rôles (<code>realm_access.roles</code>, <code>resource_access</code>).</li>
        </ul>
      </li>
      <li>
        <strong>DATA-FE-KC-002 – Pas de PII dans le stockage persistant</strong><br />
        Le front ne doit pas stocker de PII détaillées (adresse, NIP, etc.) dans <code>localStorage</code> ou
        <code>sessionStorage</code> ; uniquement les tokens et quelques métadonnées nécessaires.
      </li>
      <li>
        <strong>DATA-FE-KC-003 – Mapping rôles &amp; fonctionnalités UI</strong><br />
        Un mapping doit être documenté entre :
        <ul>
          <li>les rôles Keycloak (ex. <code>ROLE_DBA</code>, <code>ROLE_DEVOPS</code>, <code>ROLE_VIEWER</code>) ;</li>
          <li>les écrans, menus et actions visibles/activables dans le front.</li>
        </ul>
      </li>
    </ul>
  </section>

  <!-- User stories -->
  <section id="user-stories">
    <h2>7. User Stories (pour Dev AI)</h2>
    <table border="1" cellpadding="6" cellspacing="0">
      <thead>
        <tr>
          <th>ID</th>
          <th>Titre</th>
          <th>Description</th>
          <th>Priorité</th>
          <th>Système</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>US-FE-KC-001</td>
          <td>Login via Keycloak</td>
          <td>En tant qu’utilisateur, je veux me connecter au front via Keycloak pour bénéficier du SSO.</td>
          <td>Haute</td>
          <td>Front-end SPA</td>
        </tr>
        <tr>
          <td>US-FE-KC-002</td>
          <td>Routes protégées</td>
          <td>En tant qu’utilisateur, je ne veux accéder aux écrans sensibles que si je suis authentifié et autorisé.</td>
          <td>Haute</td>
          <td>Front-end SPA</td>
        </tr>
        <tr>
          <td>US-FE-KC-003</td>
          <td>Rôles &amp; menus</td>
          <td>En tant qu’admin, je veux que les menus/actions visibles dépendent de mes rôles Keycloak.</td>
          <td>Haute</td>
          <td>Front-end SPA</td>
        </tr>
        <tr>
          <td>US-FE-KC-004</td>
          <td>Appels API sécurisés</td>
          <td>En tant que système, je veux que toutes les requêtes du front vers les APIs sensibles incluent un token valide.</td>
          <td>Haute</td>
          <td>Front-end SPA</td>
        </tr>
        <tr>
          <td>US-FE-KC-005</td>
          <td>Silent refresh</td>
          <td>En tant qu’utilisateur, je veux rester connecté sans être déconnecté brutalement dès l’expiration du token.</td>
          <td>Moyenne</td>
          <td>Front-end SPA</td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- Gherkin -->
  <section id="gherkin">
    <h2>8. Scénarios Gherkin (acceptation)</h2>

    <h3>8.1 Login &amp; accès à une route protégée</h3>
    <pre><code>Scenario: Accès à une route protégée avec redirection vers Keycloak
  Given Je ne suis pas authentifié dans le front
  And La route "/admin" est protégée et nécessite un login
  When Je tente d’accéder à "/admin"
  Then Je suis redirigé vers la page de login Keycloak
  And Après authentification réussie
  And Je suis redirigé vers "/admin"
  And La page "/admin" s’affiche correctement
</code></pre>

    <h3>8.2 Menus conditionnés par les rôles</h3>
    <pre><code>Scenario: Affichage des menus selon les rôles Keycloak
  Given Je suis authentifié avec les rôles ["ROLE_DBA"]
  When L’interface principale du front se charge
  Then Le menu "Administration BD" est visible
  And Le menu "Ops avancé" est visible ou non selon les rôles configurés
  And Les menus réservés à d’autres rôles ne sont pas affichés
</code></pre>

    <h3>8.3 Token ajouté aux appels API</h3>
    <pre><code>Scenario: Appel API avec token Bearer
  Given Je suis authentifié et je possède un access_token valide
  When Le front appelle l’API "/api/db/status"
  Then L’en-tête "Authorization" de la requête contient "Bearer &lt;access_token&gt;"
  And L’API accepte la requête si le token est valide et autorisé
</code></pre>

    <h3>8.4 Expiration du token et silent refresh</h3>
    <pre><code>Scenario: Renouvellement silencieux du token avant expiration
  Given Je suis authentifié dans le front avec un access_token qui va expirer
  And Le mécanisme de silent refresh est configuré
  When Le temps restant avant expiration est inférieur au seuil configuré
  Then Le front tente un silent refresh auprès de Keycloak
  And Si le refresh réussit, un nouveau token est stocké
  And Je reste connecté sans interruption visible
</code></pre>

    <h3>8.5 Logout</h3>
    <pre><code>Scenario: Déconnexion de l’utilisateur
  Given Je suis authentifié dans le front via Keycloak
  When Je clique sur "Déconnexion"
  Then Les tokens sont supprimés du storage local
  And Je suis redirigé vers l’endpoint de logout Keycloak ou la page de login
  And Toute tentative d’accès à une route protégée déclenche un nouveau login
</code></pre>
  </section>

</main>
</body>
</html>